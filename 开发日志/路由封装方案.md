# uni-app 小程序路由封装方案

在 uni-app 中实现小程序路由封装，有以下几种常见方案：

## 方案一：基础路由封装

创建一个统一的路由管理工具类，封装所有 uni-app 提供的导航 API：

```
/src
  /utils
    /router.ts  // 路由工具类
```

### 核心思路

1. 封装所有导航方法（navigateTo, redirectTo, switchTab 等）
2. 添加路由拦截、参数处理、路由监听等功能
3. 维护路由历史和当前路由信息

## 方案二：类 Vue Router 风格封装

模仿 Vue Router 的 API 风格，创建一个更贴近 Vue Router 使用体验的路由系统：

```
/src
  /router
    /index.ts   // 路由入口
    /routes.ts  // 路由配置
    /guards.ts  // 路由守卫
```

### 核心思路

1. 集中配置所有路由
2. 提供 beforeEach、afterEach 等路由守卫功能
3. 实现类似 router-link、router-view 的组件或指令

## 方案三：状态管理结合的路由方案

结合 Pinia 或 Vuex 等状态管理库，创建路由状态管理：

```
/src
  /store
    /modules
      /app.ts      // 应用状态
      /router.ts   // 路由状态
  /router
    /index.ts      // 路由操作API
```

### 核心思路

1. 路由状态统一存储在状态管理库中
2. 导航操作同时更新路由状态
3. 组件通过状态库感知路由变化

## 具体实现——基础路由封装示例

这是最常用的方案，下面是具体实现思路：

### 1. 创建路由配置文件 (src/router/routes.ts)

```typescript
// 路由定义
export interface RouteConfig {
  path: string; // 页面路径
  name: string; // 路由名称
  tabBar?: boolean; // 是否是TabBar页面
  auth?: boolean; // 是否需要认证
}

// 应用路由配置
export const routes: Record<string, RouteConfig> = {
  home: {
    path: "/pages/index/index",
    name: "home",
    tabBar: true,
  },
  findHouse: {
    path: "/pages/find/index",
    name: "findHouse",
    tabBar: true,
  },
  friendCircle: {
    path: "/pages/friend/index",
    name: "friendCircle",
    tabBar: true,
  },
  message: {
    path: "/pages/message/index",
    name: "message",
    tabBar: true,
  },
  profile: {
    path: "/pages/profile/index",
    name: "profile",
    tabBar: true,
  },
  login: {
    path: "/pages/login/index",
    name: "login",
    auth: false,
  },
  // 其他路由...
};
```

### 2. 创建路由工具类 (src/router/index.ts)

```typescript
import { routes, RouteConfig } from "./routes";

// 路由跳转参数类型
interface RouteOptions {
  name: string;
  params?: Record<string, any>;
  query?: Record<string, string>;
}

// 当前路由信息
interface RouteInfo {
  path: string;
  fullPath: string;
  name: string;
  params: Record<string, any>;
  query: Record<string, string>;
}

class Router {
  // 当前路由信息
  private currentRoute: RouteInfo | null = null;

  // 路由历史记录
  private history: RouteInfo[] = [];

  // 获取完整路径（包含参数）
  private getFullPath(
    route: RouteConfig,
    query?: Record<string, string>
  ): string {
    if (!query || Object.keys(query).length === 0) {
      return route.path;
    }

    const queryString = Object.entries(query)
      .map(
        ([key, value]) =>
          `${encodeURIComponent(key)}=${encodeURIComponent(value)}`
      )
      .join("&");

    return `${route.path}?${queryString}`;
  }

  // 路由拦截器
  private async beforeEach(to: RouteConfig): Promise<boolean> {
    // 需要登录但未登录
    if (to.auth && !this.isLoggedIn()) {
      await this.push({ name: "login" });
      return false;
    }
    return true;
  }

  // 检查是否已登录（示例）
  private isLoggedIn(): boolean {
    const token = uni.getStorageSync("token");
    return !!token;
  }

  // 普通页面导航
  async push(options: RouteOptions): Promise<boolean> {
    const route = routes[options.name];
    if (!route) {
      console.error(`路由 "${options.name}" 不存在`);
      return false;
    }

    // 路由拦截
    const canProceed = await this.beforeEach(route);
    if (!canProceed) return false;

    // 构建完整路径
    const fullPath = this.getFullPath(route, options.query);

    // 更新当前路由信息
    this.currentRoute = {
      path: route.path,
      fullPath,
      name: options.name,
      params: options.params || {},
      query: options.query || {},
    };

    // 添加到历史记录
    this.history.push({ ...this.currentRoute });

    // TabBar页面使用switchTab，普通页面使用navigateTo
    try {
      if (route.tabBar) {
        await uni.switchTab({ url: fullPath });
      } else {
        await uni.navigateTo({ url: fullPath });
      }
      return true;
    } catch (error) {
      console.error("路由跳转失败:", error);
      return false;
    }
  }

  // 重定向（关闭当前页面）
  async replace(options: RouteOptions): Promise<boolean> {
    const route = routes[options.name];
    if (!route) {
      console.error(`路由 "${options.name}" 不存在`);
      return false;
    }

    // 路由拦截
    const canProceed = await this.beforeEach(route);
    if (!canProceed) return false;

    // 构建完整路径
    const fullPath = this.getFullPath(route, options.query);

    // 更新当前路由信息
    this.currentRoute = {
      path: route.path,
      fullPath,
      name: options.name,
      params: options.params || {},
      query: options.query || {},
    };

    try {
      if (route.tabBar) {
        await uni.switchTab({ url: fullPath });
      } else {
        await uni.redirectTo({ url: fullPath });
      }
      return true;
    } catch (error) {
      console.error("路由跳转失败:", error);
      return false;
    }
  }

  // 返回上一页
  async back(delta: number = 1): Promise<boolean> {
    try {
      await uni.navigateBack({ delta });
      // 更新历史记录
      this.history = this.history.slice(0, -delta);
      this.currentRoute = this.history[this.history.length - 1] || null;
      return true;
    } catch (error) {
      console.error("返回失败:", error);
      return false;
    }
  }

  // 重启到首页
  async reLaunch(): Promise<boolean> {
    try {
      await uni.reLaunch({ url: routes.home.path });
      this.history = [];
      this.currentRoute = {
        path: routes.home.path,
        fullPath: routes.home.path,
        name: "home",
        params: {},
        query: {},
      };
      return true;
    } catch (error) {
      console.error("重启到首页失败:", error);
      return false;
    }
  }

  // 获取当前路由
  getCurrentRoute(): RouteInfo | null {
    return this.currentRoute;
  }

  // 获取当前页面的路由参数
  getQuery(): Record<string, string> {
    const pages = getCurrentPages();
    const currentPage = pages[pages.length - 1];
    return currentPage?.$page?.query || {};
  }
}

// 创建路由实例
const router = new Router();

// 导出路由实例
export default router;
```

### 3. 使用路由 (在组件中)

```typescript
// TabBar.vue
import { ref } from "vue";
import router from "@/router";

// 当前激活的tab
const activeTab = ref(0);

// 处理tab点击
const handleTabClick = (index: number) => {
  activeTab.value = index;

  // 根据索引跳转到对应页面
  switch (index) {
    case 0:
      router.push({ name: "home" });
      break;
    case 1:
      router.push({ name: "findHouse" });
      break;
    case 2:
      router.push({ name: "friendCircle" });
      break;
    case 3:
      router.push({ name: "message" });
      break;
    case 4:
      router.push({ name: "profile" });
      break;
  }
};
```

### 4. 在应用入口注册 (main.ts)

这个多用于选项式 组合式不用管

```typescript
import { createSSRApp } from "vue";
import App from "./App.vue";
import router from "./router";

export function createApp() {
  const app = createSSRApp(App);

  // 挂载到全局，方便使用
  app.config.globalProperties.$router = router;

  return {
    app,
  };
}
```

## 方案对比和选择

1. **简单项目**：使用方案一，基础路由封装即可
2. **中大型项目**：推荐方案二或方案三，便于团队协作和维护
3. **状态管理依赖高**：如果项目已经重度使用 Pinia/Vuex，选择方案三

对于成都购房通这类应用，建议使用方案二，既保持了编码风格的一致性，又提供了足够的扩展能力。

你的 router 封装虽然与原生导航有一些重叠，但它仍然有价值，主要有以下几个原因：

## 1. 统一的路由管理

uni-app 原生提供的是分散的导航 API（uni.navigateTo, uni.redirectTo 等），而你的 router 封装提供了集中的路由管理，类似 Vue Router 的体验：

```js
// 你的封装方式
router.push({ name: "home" });

// 而不是原生方式
uni.navigateTo({ url: "/pages/home/index" });
```

## 2. 命名路由的便利性

你的路由封装支持通过名称进行导航，而不是硬编码路径：

```js
// 通过名称导航，更清晰、更不容易出错
router.push({ name: "productDetail", params: { id: 123 } });

// 而不是
uni.navigateTo({ url: `/pages/product/detail?id=${id}` });
```

## 3. 路由守卫机制

你的 router 实现了类似 Vue Router 的守卫机制，包括 beforeEach 和 afterEach：

```js
// 全局前置守卫，可以用于权限验证等
router.beforeEach((to, from, next) => {
  if (to.meta.auth && !isLoggedIn()) {
    next({ name: "login" });
  } else {
    next();
  }
});
```

这在原生 uni-app 中是没有的。

## 4. 元信息管理

路由配置中的 meta 字段可以存储路由相关的元信息：

```js
{
  path: "/pages/profile/index",
  name: "profile",
  meta: {
    title: "我的",
    tabBar: true,
    auth: false,
  }
}
```

这使得可以轻松地基于路由配置控制页面行为。

## 5. 历史记录管理

你的路由封装维护了自己的历史记录栈，可以更精确地控制导航历史：

```js
// 获取历史记录
const history = router.history;
```

## 6. 参数处理的简化

统一和简化了参数的传递和获取方式：

```js
// 传递参数
router.push({ name: "detail", params: { id: 123 }, query: { from: "list" } });

// 获取参数
const route = useRoute();
const id = route.value.params.id;
const from = route.value.query.from;
```

## 7. 类 Vue 的开发体验

对于熟悉 Vue 开发的团队，这种封装提供了更接近 Vue 单页应用的开发体验，降低了学习成本。

## 封装的真正价值

虽然在小程序这种多页应用中，路由封装不像在单页应用中那么必要，但它仍然提供了以下价值：

1. **一致性**：统一的 API 和使用模式
2. **抽象**：隐藏平台差异，为跨平台做准备
3. **扩展性**：可以添加自定义逻辑，如权限控制、参数处理
4. **可维护性**：集中管理路由配置，方便调整和重构

总之，虽然你的路由封装不能替代小程序的原生导航机制（特别是 TabBar 相关的部分），但它在开发体验、代码组织和功能扩展方面仍有很大价值。对于较复杂的应用，这种封装是值得的。
